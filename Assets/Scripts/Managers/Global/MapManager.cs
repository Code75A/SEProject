
using UnityEngine;
using UnityEngine.Tilemaps;
using UnityEngine.EventSystems;
using System.Collections.Generic;
using System;
using System.Data;
using System.Threading.Tasks;
using System.Linq;


public class MapManager : MonoBehaviour
{
    public static MapManager Instance { get; private set; }

    public const int MAP_SIZE = 64;
    public Vector3Int[] DIRECTIONS = {new Vector3Int(0, 1, 0), new Vector3Int(1, 0, 0), new Vector3Int(0, -1, 0), new Vector3Int(-1, 0, 0)};
    public const int DEBUG_MAX_PILE_NUM = 100;//TODO: 区分不同物品堆叠数量

    public class MapData{
        public Vector3Int position;
        public TileBase texture;
        public tileTypes type;

        //has_print：是否显示蓝图
        public bool has_print = false;
        //has_building：如果采用实例化building为item子类，则has_building = true必然说明has_item = true
        public bool has_building = false;
        //has_item：has_item = true 后通过item的类型判断

        public bool has_item = false; public ItemInstanceManager.ItemInstance item = null;

        //用于维护寻路点阵图
        public bool can_walk = true;
        public bool can_build = true;
        public bool can_plant = true;
        //TODO: 拓展为List<bool> cans + enum canTypes{walk,build,plant}

        public float fertility = 1.0f;
        public float humidity = 0.0f;
        public float light = 1.0f;

        public float walk_speed = 1.0f;
    }
    
    public Tilemap landTilemap;
    public enum tileTypes{
        grass,path,water,tree,farm,total
    }
    
    public TileBase[] tiles = new TileBase[(int)tileTypes.total];

    public MapData[,] mapDatas = new MapData[MAP_SIZE, MAP_SIZE];

    //TODO: 维护一个bool二位数组，用于优化物品放置时的检测
    //public bool[,] set_material_state = new bool[MAP_SIZE, MAP_SIZE];

    Dictionary<BuildManager.BuildingType, Action<MapData, BuildManager.Building>> buildActions =new Dictionary<BuildManager.BuildingType, Action<MapData, BuildManager.Building>>{
        {BuildManager.BuildingType.Dev, (data, building) => Instance.SetTileDev(data, building)},
        {BuildManager.BuildingType.Wall, (data, building) => Instance.SetTilePrint(data, building)},
        {BuildManager.BuildingType.Farm, (data, building) => Instance.SetTileFarm(data, building)}
    };
    //-------------generated by Copilot-----------------
    public void GenerateMapData(){
        for (int x = 0; x < MAP_SIZE; x++){
            for (int y = 0; y < MAP_SIZE; y++){
                mapDatas[x, y] = new MapData();
                mapDatas[x, y].type = tileTypes.grass;
                mapDatas[x, y].texture = tiles[(int)tileTypes.grass];
                mapDatas[x, y].position = new Vector3Int(x, y, 0);
            }
        }
    }
    //-------------generated by Copilot----------------- 
    public void GenerateMapTiles(){
        for (int x = 0; x < MAP_SIZE; x++){
            for (int y = 0; y < MAP_SIZE; y++){
                landTilemap.SetTile(new Vector3Int(x, y, 0), mapDatas[x, y].texture);
            }
        }
    }

    //单例模式
    void Awake(){
        if(Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start(){
        GenerateMapData();
        GenerateMapTiles();
    }

    void Update()
    {
        if(Input.GetMouseButtonDown(0)){
            // 排除点击 UI 的情况？
            // TODO: 需要更妥善地处理UI
            //if (EventSystem.current.IsPointerOverGameObject()) return;

            Vector3 mouseWorldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition); 
            Vector2 mousePos2D = new Vector2(mouseWorldPos.x, mouseWorldPos.y);

            // 排除带有 Collider2D 的 Sprite 的情况
            RaycastHit2D hitSprite = Physics2D.Raycast(mousePos2D, Vector2.zero, 0f);
            if (hitSprite.collider != null){
            //TODO： 加入更多Tag区分交互对象
            //&& hitSprite.collider.gameObject.CompareTag("Interactable"))
                
                //Debug.Log("点击到了 Sprite: " + hitSprite.collider.gameObject.name);
                return; 
            }
            
            Vector3Int cellPos = landTilemap.WorldToCell(mouseWorldPos);
            if(IsInBoard(cellPos)){

                TileBase clickedTile = landTilemap.GetTile(cellPos);
                MapData clickedData = mapDatas[cellPos.x, cellPos.y];

                if (clickedTile != null){

                    UIManager.Instance.DebugTextAdd("点击到了 Tile: " + cellPos);
                    
                    BuildManager.Building building = BuildManager.Instance.currentBuilding;
                    if(building != null){

                        UIManager.Instance.DebugTextAdd("放置建筑: " + building.name);

                        //非Dev建筑占地特判
                        if(building.type != BuildManager.BuildingType.Dev && (clickedData.has_building || clickedData.has_print)){
                            Debug.Log("此处已有建筑/蓝图，无法放置");
                            return;
                        }

                        //根据buildingType更新数据
                        if(buildActions.TryGetValue(building.type, out Action<MapData, BuildManager.Building> action))
                            action(clickedData, building);
                        else
                            Debug.Log("未定义的建筑类型: " + building.type);

                        //Dev：landtilemap更新贴图
                        if(building.type == BuildManager.BuildingType.Dev || building.type == BuildManager.BuildingType.Farm){
                            landTilemap.SetTile(cellPos, clickedData.texture);
                        }

                    }
                }
            }
            else{
                BuildManager.Instance.CancelCurrentBuilding();
            }
        }
    }

    void SetTileDev(MapData data,BuildManager.Building building){
        int id=building.id;

        data.type = (tileTypes)id;
        data.texture = tiles[id];

        data.can_build=building.can_build;
        data.can_walk=building.can_walk;
        data.can_plant=building.can_plant;

        data.has_print = false;
        data.has_building = false;
        data.has_item = false;

        if(data.item != null)
            //data.item.Destroy();
        data.item = null;

        landTilemap.SetTile(data.position, data.texture);
    }
    void SetTilePrint(MapData data, BuildManager.Building building){

        TaskManager.Instance.AddTask(data.position, TaskManager.TaskTypes.Build);

        data.has_print = true;
        data.has_item = true;
        data.can_build = false;
        data.can_plant = false;

        data.item = ItemInstanceManager.Instance.SpawnItem(data.position, building.id, ItemInstanceManager.ItemInstanceType.PrintItemInstance);
    }
    void SetTileFarm(MapData data, BuildManager.Building building){
    
        if(!data.can_plant){
            Debug.Log("此处无法种植");
            return;
        }

        data.type = tileTypes.farm;
        data.texture = tiles[(int)tileTypes.farm];

        data.has_print = false;
        data.has_building = true;
        data.has_item = true;
        data.can_build = false;
        data.can_plant = true;

        data.item = ItemInstanceManager.Instance.SpawnItem(data.position, building.id, ItemInstanceManager.ItemInstanceType.BuildingInstance);
    }

    /// <summary>
    /// 将material_list中的物品以pos为中心放置到地图上。直到地图上无空格或material_list中的物品放置完毕。
    /// </summary>
    /// <param name="pos">要放置的中心位置（包含越界检测）</param>
    /// <param name="material_list">需要放置的(id,num)列表</param>
    /// <returns></returns>
    public int SetMaterial(Vector3Int pos, List<KeyValuePair<int, int>> material_list){
        if(!IsInBoard(pos)){
            Debug.Log("Error: SetMaterial越界");
            return -1;
        }

        bool[,] visited = new bool[MAP_SIZE, MAP_SIZE];
        for(int i = 0; i < MAP_SIZE; i++){
            for(int j = 0; j < MAP_SIZE; j++){
                visited[i, j] = false;
            }
        }

        Queue<Vector3Int> checklist = new Queue<Vector3Int>();
        checklist.Enqueue(pos);

        while(checklist.Count > 0 && material_list.Count > 0){
            Vector3Int cur_check_pos = checklist.Dequeue();
            visited[cur_check_pos.x, cur_check_pos.y] = true;

            foreach(Vector3Int dir in DIRECTIONS){
                Vector3Int next_pos = cur_check_pos + dir;
                if(IsInBoard(next_pos) && !visited[next_pos.x, next_pos.y]){
                    checklist.Enqueue(next_pos);
                }
            }

            if(mapDatas[cur_check_pos.x, cur_check_pos.y].has_item){
                ItemInstanceManager.ItemInstance the_instance = mapDatas[cur_check_pos.x, cur_check_pos.y].item;
                if(the_instance is ItemInstanceManager.MaterialInstance)
                    continue;
                else
                {   
                    ItemInstanceManager.MaterialInstance the_material_instance = the_instance as ItemInstanceManager.MaterialInstance;

                    if(material_list.Any(kpv=>kpv.Key == the_instance.id)){
                        KeyValuePair<int, int> result = material_list.Find(kvp => kvp.Key == the_instance.id);

                        int unload_material_num = Math.Min(result.Value, DEBUG_MAX_PILE_NUM - the_material_instance.amount);
                        the_material_instance.amount += unload_material_num;

                        int material_num = result.Value - unload_material_num;
                        if (material_num == 0)
                            material_list.Remove(result);
                        else
                            result = new KeyValuePair<int, int>(result.Key, material_num);
                    }
                    else continue;
                }
            }
            else{
                int unload_material_num = Math.Min(material_list[0].Value, DEBUG_MAX_PILE_NUM);
                mapDatas[cur_check_pos.x, cur_check_pos.y].has_item = true;
                mapDatas[cur_check_pos.x, cur_check_pos.y].item = ItemInstanceManager.Instance.SpawnItem(
                    cur_check_pos, material_list[0].Key, ItemInstanceManager.ItemInstanceType.MaterialInstance, unload_material_num);
                
                int material_num = material_list[0].Value - unload_material_num;
                if (material_num == 0)
                    material_list.RemoveAt(0);
                else
                    material_list[0] = new KeyValuePair<int, int>(material_list[0].Key, material_num);
            }
        }
        
        return 1;
    }

    bool IsInBoard(Vector3Int pos){
        return pos.x >= 0 && pos.x < MAP_SIZE && pos.y >= 0 && pos.y < MAP_SIZE;
    }
}
