using System;
using System.Collections.Generic;

//some of this code generated by ChatGPT & copilot

/// <summary>PriorityQueue替代品</summary>
/// <typeparam name="TElement">必须非空</typeparam>
/// <typeparam name="TPriority">必须是可比较值</typeparam>
public class MyPriorityQueue<TElement, TPriority> 
    where TElement : notnull 
    where TPriority : IComparable<TPriority>
{
    private List<(TElement Element, TPriority Priority)> heap = new();
    public int Count => heap.Count;

    private void HeapifyUp(int index){
        while(index > 0){
            int parent_index = (index - 1) / 2;
            if(heap[index].Priority.CompareTo(heap[parent_index].Priority) >= 0) break;
            (heap[index], heap[parent_index]) = (heap[parent_index], heap[index]);
            index = parent_index;
        }
    }
    private void HeapifyDown(int index){
        int last_index = heap.Count - 1;

        while(index <= last_index){
            int left_child_index = index * 2 + 1;
            int right_child_index = index * 2 + 2;

            if(left_child_index > last_index) break;

            int smallest_child_index = left_child_index;

            if(right_child_index <= last_index && heap[right_child_index].Priority.CompareTo(heap[left_child_index].Priority) < 0){
                smallest_child_index = right_child_index;
            }

            if(heap[index].Priority.CompareTo(heap[smallest_child_index].Priority) <= 0) break;

            (heap[index], heap[smallest_child_index]) = (heap[smallest_child_index], heap[index]);
            index = smallest_child_index;
        }
    }

    public void Enqueue(TElement element, TPriority priority)
    {
        heap.Add((element, priority));

        int childIndex = heap.Count - 1;
        HeapifyUp(childIndex);
    }
    
    
    public TElement Dequeue()
    {
        if (heap.Count == 0) throw new InvalidOperationException("Queue is empty.");
        
        TElement result = heap[0].Element;

        int last_index = heap.Count - 1;
        (heap[0], heap[last_index]) = (heap[last_index], heap[0]);

        heap.RemoveAt(last_index);
        HeapifyDown(0);

        return result;
    }
    public TElement Peek(){
        if (heap.Count == 0) throw new InvalidOperationException("Queue is empty.");
        return heap[0].Element;
    }
    public bool Empty(){
        return heap.Count == 0;
    }
    public void Clear(){
        heap.Clear();
    }
}